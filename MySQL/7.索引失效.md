背景：创建员工表staffs。为其字段name,age,pos创建复合索引即索引中的顺序name为1，age为2，pos为3

# 失效原因

### 1.全值匹配我最爱

- 当你创建的索引字段和where后的搜索字段一致则索引完全使用(如：where name=1 and age=1 and pos=1)
- 当where后的搜索字段与索引不一致，也会使用索引(如：where name=1 或 where name=1 and age=1)
- 当where后的搜索字段与索引不一致，索引失效(如：where age=1 and pos=1)，变成全表扫描
- 复合索引中字段的顺序很重要，就和走楼梯一样。背景中name在索引中的顺序为1相当于第一层，不使用这个字段查询就等于把梯子抽了，这样上面二三层的索引就用不上了



### 2.最佳左前缀法则

- 如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始且不跳过索引中的列
- 该法则就是上面走楼梯的例子
- 口诀：带头大哥不能死，中间兄弟不能断。带头大哥即第一个顺序位的索引。中间兄弟如果断了只会部分使用索引



### 3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描

- 对索引列进行操作(如：where left(name,4)='July')。会导致索引失效



### 4.存储引擎不能使用索引中范围条件右边的列

- “>”,"<"",between这些操作以后索引失效。
- where name=1 and age>1 and pos=1会pos的索引失效，只使用了name和age的索引
- 范围列的索引只用于排序没有用于查找



### 5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select \*

- 这样可以触发索引覆盖，extra中会出现using index。这样代表数据直接从索引中获取，不需要读表
- 取什么用什么，不要写*
- 如果where中有范围查询，虽然也会使索引失效，但key_len比较小，对数据库负担会小一些



### 6.mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描

- 注意<>是不等号。
- 和范围查询一样会导致索引失效



### 7.is null,is not null 也无法使用索引

- 避免null值，最好设置字段为not null。并且设置default值
- 当要查询时查询这个特殊值，这样就可以用到索引



### 8.like以通配符开头（'$abc...'）mysql索引失效会变成全表扫描操作

- '%July%'和'%July'会导致全表扫描
- 'July%'不会全表扫描，会变成range类型的查询，但后面的字段索引就失效(新版本好像优化了，后面也可以使用到索引)
- 所以like查询把通配符写在后面效率高，因为会用到索引
- 如果两边%则通过覆盖索引提高效率，即只查询创建索引的列。这样查询type是index。
- 'a%aa%'可以用到索引



### 9.字符串不加单引号索引失效

- where name=2000和where name='2000'虽然都能搜到答案，但前者会导致索引失效

- 其实就是mysql自动做了一次类型转换，也就是第三条的问题

  

### 10.少用or,用它连接时会索引失效

